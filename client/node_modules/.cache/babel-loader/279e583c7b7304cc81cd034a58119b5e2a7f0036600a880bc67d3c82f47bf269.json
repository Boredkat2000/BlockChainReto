{"ast":null,"code":"import { setupWeb3Provider } from '../utils/web3Utils';\n\n/**\n * Servicio de autenticación para manejar la conexión con MetaMask y firma de mensajes\n */\nexport const authService = {\n  /**\n   * Conecta con MetaMask y autentica al usuario\n   * @param {string} userName - Nombre del usuario (opcional)\n   * @param {string} cedula - Cédula de identidad dominicana\n   * @returns {Promise<{success: boolean, address: string, token: string, name: string}|{success: boolean, error: string}>}\n   */\n  connectWallet: async (userName = '', cedula = '') => {\n    try {\n      console.log('Iniciando conectWallet con:', {\n        userName,\n        cedula\n      });\n\n      // Validación más estricta para la cédula\n      if (!cedula) {\n        console.error('Cédula completamente vacía');\n        return {\n          success: false,\n          error: 'Cédula no proporcionada'\n        };\n      }\n      if (typeof cedula !== 'string' && typeof cedula !== 'number') {\n        console.error('Tipo de cédula incorrecto:', typeof cedula);\n        return {\n          success: false,\n          error: `Cédula con formato incorrecto (${typeof cedula})`\n        };\n      }\n\n      // Limpiar y verificar la cédula - asegurarse de convertirla a string\n      const cedulaStr = String(cedula);\n      const cleanCedula = cedulaStr.replace(/[-\\s]/g, '');\n      console.log('Cédula original:', cedula);\n      console.log('Cédula como string:', cedulaStr);\n      console.log('Cédula limpia para validación:', cleanCedula, 'Longitud:', cleanCedula.length);\n\n      // Verificar que solo contiene números\n      if (!/^\\d+$/.test(cleanCedula)) {\n        console.error('La cédula contiene caracteres no numéricos:', cleanCedula);\n        return {\n          success: false,\n          error: 'La cédula solo debe contener números'\n        };\n      }\n\n      // Verificar formato de cédula dominicana\n      const cedulaRegex = /^(012|402)\\d{8}$/;\n      if (!cedulaRegex.test(cleanCedula)) {\n        console.error('Formato de cédula inválido:', cleanCedula);\n        return {\n          success: false,\n          error: 'Formato de cédula inválido. Debe comenzar con 012 o 402 y tener 11 dígitos.'\n        };\n      }\n\n      // Configurar proveedor Web3\n      const web3Setup = await setupWeb3Provider();\n      if (!web3Setup) {\n        console.error('No se pudo configurar Web3');\n        return {\n          success: false,\n          error: 'No se pudo conectar a MetaMask'\n        };\n      }\n      const {\n        signer\n      } = web3Setup; // Solo necesitamos el signer para la autenticación\n      const address = await signer.getAddress();\n      if (!address) {\n        console.error('No se pudo obtener dirección de billetera');\n        return {\n          success: false,\n          error: 'No se pudo obtener la dirección de la billetera'\n        };\n      }\n      console.log('Dirección obtenida:', address);\n\n      // Obtener nonce del servidor usando la ruta relativa con el proxy\n      console.log('Solicitando nonce al servidor...');\n      let nonceData = null;\n      try {\n        console.log('Conectando a /api/auth/nonce mediante proxy');\n        const nonceResponse = await fetch('/api/auth/nonce', {\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          signal: AbortSignal.timeout(5000)\n        });\n        if (!nonceResponse.ok) {\n          const errorText = await nonceResponse.text();\n          throw new Error(`Error en respuesta del servidor: ${nonceResponse.status} ${errorText}`);\n        }\n        nonceData = await nonceResponse.json();\n        console.log('Respuesta del servidor (nonce):', nonceData);\n        if (!nonceData.success) {\n          console.error('Error al obtener nonce:', nonceData);\n          return {\n            success: false,\n            error: nonceData.message || 'Error al obtener nonce de autenticación'\n          };\n        }\n      } catch (error) {\n        console.error('Error al solicitar nonce:', error);\n        return {\n          success: false,\n          error: `No se pudo conectar al servidor. ${error.message || 'Verifique que el servidor esté en ejecución.'}`\n        };\n      }\n\n      // Firmar mensaje con nonce\n      console.log('Firmando mensaje con nonce:', nonceData.message);\n      let signature;\n      try {\n        signature = await signer.signMessage(nonceData.message);\n        console.log('Firma generada:', signature);\n        if (!signature) {\n          console.error('No se generó firma');\n          return {\n            success: false,\n            error: 'Error al firmar el mensaje'\n          };\n        }\n      } catch (signError) {\n        console.error('Error al firmar mensaje:', signError);\n        return {\n          success: false,\n          error: 'Error al firmar el mensaje: ' + signError.message\n        };\n      }\n\n      // Verificar firma en el servidor (también usando la ruta relativa)\n      console.log('Enviando datos para verificación:', {\n        address,\n        signature: signature ? 'presente' : 'ausente',\n        message: nonceData.message,\n        name: userName,\n        cedula: cleanCedula\n      });\n      let authData;\n      try {\n        console.log('Enviando verificación de firma a /api/auth/verify-signature');\n        const authResponse = await fetch('/api/auth/verify-signature', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            address,\n            signature,\n            message: nonceData.message,\n            name: userName || 'Usuario',\n            // Asegurar que siempre haya un nombre\n            cedula: cleanCedula\n          })\n        });\n        if (!authResponse.ok) {\n          const errorText = await authResponse.text();\n          throw new Error(`Error en respuesta del servidor: ${authResponse.status} ${errorText}`);\n        }\n        authData = await authResponse.json();\n        console.log('Respuesta de verificación:', authData);\n        if (!authData.success) {\n          console.error('Error en verificación:', authData);\n          return {\n            success: false,\n            error: authData.message || 'Error de autenticación'\n          };\n        }\n      } catch (authError) {\n        console.error('Error al enviar verificación:', authError);\n        return {\n          success: false,\n          error: 'Error de conexión al verificar firma: ' + authError.message\n        };\n      }\n\n      // Autenticación exitosa\n      return {\n        success: true,\n        address,\n        token: authData.token,\n        name: authData.name || 'Usuario'\n      };\n    } catch (error) {\n      console.error('Error en autenticación:', error);\n      return {\n        success: false,\n        error: error.message || 'Error desconocido durante la autenticación'\n      };\n    }\n  },\n  /**\n   * Verifica si hay una sesiu00f3n activa guardada\n   * @returns {boolean}\n   */\n  hasActiveSession: () => {\n    const token = localStorage.getItem('auth_token');\n    const address = localStorage.getItem('user_address');\n    return !!(token && address);\n  },\n  /**\n   * Obtiene el token de autenticaciu00f3n actual\n   * @returns {string|null}\n   */\n  getAuthToken: () => {\n    return localStorage.getItem('auth_token');\n  },\n  /**\n   * Obtiene la direcciu00f3n de billetera guardada\n   * @returns {string|null}\n   */\n  getSavedAddress: () => {\n    return localStorage.getItem('user_address');\n  },\n  /**\n   * Obtiene el nombre del usuario guardado\n   * @returns {string|null}\n   */\n  getSavedName: () => {\n    return localStorage.getItem('user_name');\n  },\n  /**\n   * Guarda la informaciu00f3n de sesiu00f3n\n   * @param {string} address - Direcciu00f3n de la billetera\n   * @param {string} token - Token JWT\n   * @param {string} name - Nombre del usuario\n   */\n  saveSession: (address, token, name) => {\n    localStorage.setItem('auth_token', token);\n    localStorage.setItem('user_address', address);\n    localStorage.setItem('user_name', name);\n  },\n  /**\n   * Cierra la sesiu00f3n\n   */\n  logout: () => {\n    localStorage.removeItem('auth_token');\n    localStorage.removeItem('user_address');\n    localStorage.removeItem('user_name');\n  },\n  /**\n   * Verifica si la direcciu00f3n proporcionada es un administrador\n   * @param {string} address - Direcciu00f3n a verificar\n   * @returns {boolean}\n   */\n  isAdmin: address => {\n    const adminAddress = process.env.REACT_APP_ADMIN_ADDRESS;\n    if (!adminAddress || !address) return false;\n    return address.toLowerCase() === adminAddress.toLowerCase();\n  }\n};","map":{"version":3,"names":["setupWeb3Provider","authService","connectWallet","userName","cedula","console","log","error","success","cedulaStr","String","cleanCedula","replace","length","test","cedulaRegex","web3Setup","signer","address","getAddress","nonceData","nonceResponse","fetch","headers","signal","AbortSignal","timeout","ok","errorText","text","Error","status","json","message","signature","signMessage","signError","name","authData","authResponse","method","body","JSON","stringify","authError","token","hasActiveSession","localStorage","getItem","getAuthToken","getSavedAddress","getSavedName","saveSession","setItem","logout","removeItem","isAdmin","adminAddress","process","env","REACT_APP_ADMIN_ADDRESS","toLowerCase"],"sources":["C:/Users/katri/CascadeProjects/blockchain-voting-platform/client/src/services/authService.js"],"sourcesContent":["import { setupWeb3Provider } from '../utils/web3Utils';\n\n/**\n * Servicio de autenticación para manejar la conexión con MetaMask y firma de mensajes\n */\nexport const authService = {\n  /**\n   * Conecta con MetaMask y autentica al usuario\n   * @param {string} userName - Nombre del usuario (opcional)\n   * @param {string} cedula - Cédula de identidad dominicana\n   * @returns {Promise<{success: boolean, address: string, token: string, name: string}|{success: boolean, error: string}>}\n   */\n  connectWallet: async (userName = '', cedula = '') => {\n    try {\n      console.log('Iniciando conectWallet con:', { userName, cedula });\n      \n      // Validación más estricta para la cédula\n      if (!cedula) {\n        console.error('Cédula completamente vacía');\n        return { success: false, error: 'Cédula no proporcionada' };\n      }\n      \n      if (typeof cedula !== 'string' && typeof cedula !== 'number') {\n        console.error('Tipo de cédula incorrecto:', typeof cedula);\n        return { success: false, error: `Cédula con formato incorrecto (${typeof cedula})` };\n      }\n      \n      // Limpiar y verificar la cédula - asegurarse de convertirla a string\n      const cedulaStr = String(cedula);\n      const cleanCedula = cedulaStr.replace(/[-\\s]/g, '');\n      console.log('Cédula original:', cedula);\n      console.log('Cédula como string:', cedulaStr);\n      console.log('Cédula limpia para validación:', cleanCedula, 'Longitud:', cleanCedula.length);\n      \n      // Verificar que solo contiene números\n      if (!/^\\d+$/.test(cleanCedula)) {\n        console.error('La cédula contiene caracteres no numéricos:', cleanCedula);\n        return { success: false, error: 'La cédula solo debe contener números' };\n      }\n      \n      // Verificar formato de cédula dominicana\n      const cedulaRegex = /^(012|402)\\d{8}$/;\n      if (!cedulaRegex.test(cleanCedula)) {\n        console.error('Formato de cédula inválido:', cleanCedula);\n        return { success: false, error: 'Formato de cédula inválido. Debe comenzar con 012 o 402 y tener 11 dígitos.' };\n      }\n      \n      // Configurar proveedor Web3\n      const web3Setup = await setupWeb3Provider();\n      if (!web3Setup) {\n        console.error('No se pudo configurar Web3');\n        return { success: false, error: 'No se pudo conectar a MetaMask' };\n      }\n      \n      const { signer } = web3Setup; // Solo necesitamos el signer para la autenticación\n      const address = await signer.getAddress();\n      \n      if (!address) {\n        console.error('No se pudo obtener dirección de billetera');\n        return { success: false, error: 'No se pudo obtener la dirección de la billetera' };\n      }\n      \n      console.log('Dirección obtenida:', address);\n      \n      // Obtener nonce del servidor usando la ruta relativa con el proxy\n      console.log('Solicitando nonce al servidor...');\n      let nonceData = null;\n      \n      try {\n        console.log('Conectando a /api/auth/nonce mediante proxy');\n        \n        const nonceResponse = await fetch('/api/auth/nonce', {\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          signal: AbortSignal.timeout(5000)\n        });\n        \n        if (!nonceResponse.ok) {\n          const errorText = await nonceResponse.text();\n          throw new Error(`Error en respuesta del servidor: ${nonceResponse.status} ${errorText}`);\n        }\n        \n        nonceData = await nonceResponse.json();\n        console.log('Respuesta del servidor (nonce):', nonceData);\n        \n        if (!nonceData.success) {\n          console.error('Error al obtener nonce:', nonceData);\n          return { success: false, error: nonceData.message || 'Error al obtener nonce de autenticación' };\n        }\n      } catch (error) {\n        console.error('Error al solicitar nonce:', error);\n        return { \n          success: false, \n          error: `No se pudo conectar al servidor. ${error.message || 'Verifique que el servidor esté en ejecución.'}` \n        };\n      }\n      \n      // Firmar mensaje con nonce\n      console.log('Firmando mensaje con nonce:', nonceData.message);\n      let signature;\n      try {\n        signature = await signer.signMessage(nonceData.message);\n        console.log('Firma generada:', signature);\n        \n        if (!signature) {\n          console.error('No se generó firma');\n          return { success: false, error: 'Error al firmar el mensaje' };\n        }\n      } catch (signError) {\n        console.error('Error al firmar mensaje:', signError);\n        return { success: false, error: 'Error al firmar el mensaje: ' + signError.message };\n      }\n      \n      // Verificar firma en el servidor (también usando la ruta relativa)\n      console.log('Enviando datos para verificación:', {\n        address,\n        signature: signature ? 'presente' : 'ausente',\n        message: nonceData.message,\n        name: userName,\n        cedula: cleanCedula\n      });\n      \n      let authData;\n      try {\n        console.log('Enviando verificación de firma a /api/auth/verify-signature');\n        \n        const authResponse = await fetch('/api/auth/verify-signature', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            address,\n            signature,\n            message: nonceData.message,\n            name: userName || 'Usuario', // Asegurar que siempre haya un nombre\n            cedula: cleanCedula\n          })\n        });\n        \n        if (!authResponse.ok) {\n          const errorText = await authResponse.text();\n          throw new Error(`Error en respuesta del servidor: ${authResponse.status} ${errorText}`);\n        }\n        \n        authData = await authResponse.json();\n        console.log('Respuesta de verificación:', authData);\n        \n        if (!authData.success) {\n          console.error('Error en verificación:', authData);\n          return { success: false, error: authData.message || 'Error de autenticación' };\n        }\n      } catch (authError) {\n        console.error('Error al enviar verificación:', authError);\n        return { success: false, error: 'Error de conexión al verificar firma: ' + authError.message };\n      }\n      \n      // Autenticación exitosa\n      return {\n        success: true,\n        address,\n        token: authData.token,\n        name: authData.name || 'Usuario'\n      };\n    } catch (error) {\n      console.error('Error en autenticación:', error);\n      return {\n        success: false,\n        error: error.message || 'Error desconocido durante la autenticación'\n      };\n    }\n  },\n  \n  /**\n   * Verifica si hay una sesiu00f3n activa guardada\n   * @returns {boolean}\n   */\n  hasActiveSession: () => {\n    const token = localStorage.getItem('auth_token');\n    const address = localStorage.getItem('user_address');\n    return !!(token && address);\n  },\n  \n  /**\n   * Obtiene el token de autenticaciu00f3n actual\n   * @returns {string|null}\n   */\n  getAuthToken: () => {\n    return localStorage.getItem('auth_token');\n  },\n  \n  /**\n   * Obtiene la direcciu00f3n de billetera guardada\n   * @returns {string|null}\n   */\n  getSavedAddress: () => {\n    return localStorage.getItem('user_address');\n  },\n  \n  /**\n   * Obtiene el nombre del usuario guardado\n   * @returns {string|null}\n   */\n  getSavedName: () => {\n    return localStorage.getItem('user_name');\n  },\n  \n  /**\n   * Guarda la informaciu00f3n de sesiu00f3n\n   * @param {string} address - Direcciu00f3n de la billetera\n   * @param {string} token - Token JWT\n   * @param {string} name - Nombre del usuario\n   */\n  saveSession: (address, token, name) => {\n    localStorage.setItem('auth_token', token);\n    localStorage.setItem('user_address', address);\n    localStorage.setItem('user_name', name);\n  },\n  \n  /**\n   * Cierra la sesiu00f3n\n   */\n  logout: () => {\n    localStorage.removeItem('auth_token');\n    localStorage.removeItem('user_address');\n    localStorage.removeItem('user_name');\n  },\n  \n  /**\n   * Verifica si la direcciu00f3n proporcionada es un administrador\n   * @param {string} address - Direcciu00f3n a verificar\n   * @returns {boolean}\n   */\n  isAdmin: (address) => {\n    const adminAddress = process.env.REACT_APP_ADMIN_ADDRESS;\n    if (!adminAddress || !address) return false;\n    return address.toLowerCase() === adminAddress.toLowerCase();\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}