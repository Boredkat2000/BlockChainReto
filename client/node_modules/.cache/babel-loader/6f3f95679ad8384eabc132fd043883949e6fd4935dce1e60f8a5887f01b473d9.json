{"ast":null,"code":"import { setupWeb3Provider } from '../utils/web3Utils';\n\n/**\n * Servicio de autenticaciu00f3n para manejar la conexiu00f3n con MetaMask y firma de mensajes\n */\nexport const authService = {\n  /**\n   * Conecta con MetaMask y autentica al usuario\n   * @param {string} userName - Nombre del usuario (opcional)\n   * @param {string} cedula - Cédula de identidad dominicana\n   * @returns {Promise<{success: boolean, address: string, token: string, name: string}|{success: boolean, error: string}>}\n   */\n  connectWallet: async (userName = '', cedula = '') => {\n    try {\n      console.log('Iniciando conectWallet con:', {\n        userName,\n        cedula\n      });\n\n      // Validación más estricta para la cédula\n      if (!cedula) {\n        console.error('Cédula completamente vacía');\n        return {\n          success: false,\n          error: 'Cédula no proporcionada'\n        };\n      }\n      if (typeof cedula !== 'string' && typeof cedula !== 'number') {\n        console.error('Tipo de cédula incorrecto:', typeof cedula);\n        return {\n          success: false,\n          error: `Cédula con formato incorrecto (${typeof cedula})`\n        };\n      }\n\n      // Limpiar y verificar la cédula - asegurarse de convertirla a string\n      const cedulaStr = String(cedula);\n      const cleanCedula = cedulaStr.replace(/[-\\s]/g, '');\n      console.log('Cédula original:', cedula);\n      console.log('Cédula como string:', cedulaStr);\n      console.log('Cédula limpia para validación:', cleanCedula, 'Longitud:', cleanCedula.length);\n\n      // Verificar que solo contiene números\n      if (!/^\\d+$/.test(cleanCedula)) {\n        console.error('La cédula contiene caracteres no numéricos:', cleanCedula);\n        return {\n          success: false,\n          error: 'La cédula solo debe contener números'\n        };\n      }\n\n      // Verificar formato de cédula dominicana\n      const cedulaRegex = /^(012|402)\\d{8}$/;\n      if (!cedulaRegex.test(cleanCedula)) {\n        console.error('Formato de cédula inválido:', cleanCedula);\n        return {\n          success: false,\n          error: 'Formato de cédula inválido. Debe comenzar con 012 o 402 y tener 11 dígitos.'\n        };\n      }\n\n      // Configurar proveedor Web3\n      const web3Setup = await setupWeb3Provider();\n      if (!web3Setup) {\n        console.error('No se pudo configurar Web3');\n        return {\n          success: false,\n          error: 'No se pudo conectar a MetaMask'\n        };\n      }\n      const {\n        signer\n      } = web3Setup; // Solo necesitamos el signer para la autenticación\n      const address = await signer.getAddress();\n      if (!address) {\n        console.error('No se pudo obtener dirección de billetera');\n        return {\n          success: false,\n          error: 'No se pudo obtener la dirección de la billetera'\n        };\n      }\n      console.log('Dirección obtenida:', address);\n\n      // Obtener nonce del servidor\n      console.log('Solicitando nonce al servidor...');\n      let nonceData = null;\n      const maxRetries = 3;\n      let retryCount = 0;\n      let lastError = null;\n\n      // Intentar con diferentes puertos si es necesario\n      const serverUrls = [process.env.REACT_APP_API_URL, 'http://localhost:4001',\n      // Nuevo puerto\n      'http://127.0.0.1:4001',\n      // Nuevo puerto\n      'http://localhost:5000',\n      // Puertos anteriores como fallback\n      'http://localhost:3333', 'http://127.0.0.1:5000', 'http://127.0.0.1:3333'].filter(Boolean); // Eliminar valores nulos o indefinidos\n\n      console.log('Intentando conexión con las siguientes URLs:', serverUrls);\n\n      // Intentar encontrar un servidor que responda\n      let foundServer = false;\n      retry: while (retryCount < maxRetries && !foundServer) {\n        for (const serverUrl of serverUrls) {\n          try {\n            console.log(`Intento ${retryCount + 1}/${maxRetries} - Conectando a ${serverUrl}/api/auth/nonce`);\n            const nonceResponse = await fetch(`${serverUrl}/api/auth/nonce`, {\n              headers: {\n                'Content-Type': 'application/json'\n              },\n              // Reducir el tiempo de espera para fallar más rápido si un servidor no responde\n              signal: AbortSignal.timeout(3000)\n            });\n            const responseData = await nonceResponse.json();\n            console.log('Respuesta del servidor (nonce):', responseData);\n            if (!responseData.success) {\n              console.error('Error al obtener nonce:', responseData);\n              lastError = responseData.message || 'Error al obtener nonce de autenticación';\n              continue; // Probar con la siguiente URL\n            }\n\n            // Si llegamos aquí, hemos tenido éxito\n            console.log(`Conexión exitosa a ${serverUrl}`);\n            // Guardar la URL que funcionó para usarla en futuras solicitudes\n            localStorage.setItem('server_api_url', serverUrl);\n            nonceData = responseData;\n            foundServer = true;\n            break retry; // Salir de ambos bucles\n          } catch (error) {\n            console.error(`Error al conectar con ${serverUrl}:`, error);\n            lastError = error.message || 'Error de conexión al solicitar nonce';\n            // Continuamos con la siguiente URL\n          }\n        }\n        retryCount++;\n        if (retryCount < maxRetries && !foundServer) {\n          console.log(`Reintentando en 1 segundo... (${retryCount}/${maxRetries})`);\n          await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar 1 segundo antes de reintentar\n        }\n      }\n\n      // Si no se encontró ninguna conexión válida, devolver error\n      if (!foundServer || !nonceData) {\n        console.error('Todos los intentos de conexión fallaron');\n        return {\n          success: false,\n          error: `No se pudo conectar al servidor. ${lastError || 'Verifique que el servidor esté en ejecución.'}`\n        };\n      }\n      console.log('Nonce obtenido con éxito:', nonceData.message);\n\n      // Firmar mensaje con nonce\n      console.log('Firmando mensaje con nonce:', nonceData.message);\n      let signature;\n      try {\n        signature = await signer.signMessage(nonceData.message);\n        console.log('Firma generada:', signature);\n        if (!signature) {\n          console.error('No se generó firma');\n          return {\n            success: false,\n            error: 'Error al firmar el mensaje'\n          };\n        }\n      } catch (signError) {\n        console.error('Error al firmar mensaje:', signError);\n        return {\n          success: false,\n          error: 'Error al firmar el mensaje: ' + signError.message\n        };\n      }\n\n      // Verificar firma en el servidor\n      console.log('Enviando datos para verificación:', {\n        address,\n        signature: signature ? 'presente' : 'ausente',\n        message: nonceData.message,\n        name: userName,\n        cedula: cedula\n      });\n      let authData;\n      try {\n        // Usar la URL que funcionó para el nonce\n        const serverUrl = localStorage.getItem('server_api_url') || process.env.REACT_APP_API_URL || 'http://localhost:5000';\n        console.log(`Enviando verificación de firma a ${serverUrl}/api/auth/verify-signature`);\n        const authResponse = await fetch(`${serverUrl}/api/auth/verify-signature`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            address,\n            signature,\n            message: nonceData.message,\n            name: userName || 'Usuario',\n            // Asegurar que siempre haya un nombre\n            cedula: cedula\n          })\n        });\n        authData = await authResponse.json();\n        console.log('Respuesta de verificación:', authData);\n        if (!authData.success) {\n          console.error('Error en verificación:', authData);\n          return {\n            success: false,\n            error: authData.message || 'Error de autenticación'\n          };\n        }\n      } catch (authError) {\n        console.error('Error al enviar verificación:', authError);\n        return {\n          success: false,\n          error: 'Error de conexión al verificar firma. Verifique que el servidor esté en ejecución.'\n        };\n      }\n\n      // Autenticaciu00f3n exitosa\n      return {\n        success: true,\n        address,\n        token: authData.token,\n        name: authData.name || 'Usuario'\n      };\n    } catch (error) {\n      console.error('Error en autenticaciu00f3n:', error);\n      return {\n        success: false,\n        error: error.message || 'Error desconocido durante la autenticaciu00f3n'\n      };\n    }\n  },\n  /**\n   * Verifica si hay una sesiu00f3n activa guardada\n   * @returns {boolean}\n   */\n  hasActiveSession: () => {\n    const token = localStorage.getItem('auth_token');\n    const address = localStorage.getItem('user_address');\n    return !!(token && address);\n  },\n  /**\n   * Obtiene el token de autenticaciu00f3n actual\n   * @returns {string|null}\n   */\n  getAuthToken: () => {\n    return localStorage.getItem('auth_token');\n  },\n  /**\n   * Obtiene la direcciu00f3n de billetera guardada\n   * @returns {string|null}\n   */\n  getSavedAddress: () => {\n    return localStorage.getItem('user_address');\n  },\n  /**\n   * Obtiene el nombre del usuario guardado\n   * @returns {string|null}\n   */\n  getSavedName: () => {\n    return localStorage.getItem('user_name');\n  },\n  /**\n   * Guarda la informaciu00f3n de sesiu00f3n\n   * @param {string} address - Direcciu00f3n de la billetera\n   * @param {string} token - Token JWT\n   * @param {string} name - Nombre del usuario\n   */\n  saveSession: (address, token, name) => {\n    localStorage.setItem('auth_token', token);\n    localStorage.setItem('user_address', address);\n    localStorage.setItem('user_name', name);\n  },\n  /**\n   * Cierra la sesiu00f3n\n   */\n  logout: () => {\n    localStorage.removeItem('auth_token');\n    localStorage.removeItem('user_address');\n    localStorage.removeItem('user_name');\n  },\n  /**\n   * Verifica si la direcciu00f3n proporcionada es un administrador\n   * @param {string} address - Direcciu00f3n a verificar\n   * @returns {boolean}\n   */\n  isAdmin: address => {\n    const adminAddress = process.env.REACT_APP_ADMIN_ADDRESS;\n    if (!adminAddress || !address) return false;\n    return address.toLowerCase() === adminAddress.toLowerCase();\n  }\n};","map":{"version":3,"names":["setupWeb3Provider","authService","connectWallet","userName","cedula","console","log","error","success","cedulaStr","String","cleanCedula","replace","length","test","cedulaRegex","web3Setup","signer","address","getAddress","nonceData","maxRetries","retryCount","lastError","serverUrls","process","env","REACT_APP_API_URL","filter","Boolean","foundServer","retry","serverUrl","nonceResponse","fetch","headers","signal","AbortSignal","timeout","responseData","json","message","localStorage","setItem","Promise","resolve","setTimeout","signature","signMessage","signError","name","authData","getItem","authResponse","method","body","JSON","stringify","authError","token","hasActiveSession","getAuthToken","getSavedAddress","getSavedName","saveSession","logout","removeItem","isAdmin","adminAddress","REACT_APP_ADMIN_ADDRESS","toLowerCase"],"sources":["C:/Users/katri/CascadeProjects/blockchain-voting-platform/client/src/services/authService.js"],"sourcesContent":["import { setupWeb3Provider } from '../utils/web3Utils';\n\n/**\n * Servicio de autenticaciu00f3n para manejar la conexiu00f3n con MetaMask y firma de mensajes\n */\nexport const authService = {\n  /**\n   * Conecta con MetaMask y autentica al usuario\n   * @param {string} userName - Nombre del usuario (opcional)\n   * @param {string} cedula - Cédula de identidad dominicana\n   * @returns {Promise<{success: boolean, address: string, token: string, name: string}|{success: boolean, error: string}>}\n   */\n  connectWallet: async (userName = '', cedula = '') => {\n    try {\n      console.log('Iniciando conectWallet con:', { userName, cedula });\n      \n      // Validación más estricta para la cédula\n      if (!cedula) {\n        console.error('Cédula completamente vacía');\n        return { success: false, error: 'Cédula no proporcionada' };\n      }\n      \n      if (typeof cedula !== 'string' && typeof cedula !== 'number') {\n        console.error('Tipo de cédula incorrecto:', typeof cedula);\n        return { success: false, error: `Cédula con formato incorrecto (${typeof cedula})` };\n      }\n      \n      // Limpiar y verificar la cédula - asegurarse de convertirla a string\n      const cedulaStr = String(cedula);\n      const cleanCedula = cedulaStr.replace(/[-\\s]/g, '');\n      console.log('Cédula original:', cedula);\n      console.log('Cédula como string:', cedulaStr);\n      console.log('Cédula limpia para validación:', cleanCedula, 'Longitud:', cleanCedula.length);\n      \n      // Verificar que solo contiene números\n      if (!/^\\d+$/.test(cleanCedula)) {\n        console.error('La cédula contiene caracteres no numéricos:', cleanCedula);\n        return { success: false, error: 'La cédula solo debe contener números' };\n      }\n      \n      // Verificar formato de cédula dominicana\n      const cedulaRegex = /^(012|402)\\d{8}$/;\n      if (!cedulaRegex.test(cleanCedula)) {\n        console.error('Formato de cédula inválido:', cleanCedula);\n        return { success: false, error: 'Formato de cédula inválido. Debe comenzar con 012 o 402 y tener 11 dígitos.' };\n      }\n      \n      // Configurar proveedor Web3\n      const web3Setup = await setupWeb3Provider();\n      if (!web3Setup) {\n        console.error('No se pudo configurar Web3');\n        return { success: false, error: 'No se pudo conectar a MetaMask' };\n      }\n      \n      const { signer } = web3Setup; // Solo necesitamos el signer para la autenticación\n      const address = await signer.getAddress();\n      \n      if (!address) {\n        console.error('No se pudo obtener dirección de billetera');\n        return { success: false, error: 'No se pudo obtener la dirección de la billetera' };\n      }\n      \n      console.log('Dirección obtenida:', address);\n      \n      // Obtener nonce del servidor\n      console.log('Solicitando nonce al servidor...');\n      let nonceData = null;\n      const maxRetries = 3;\n      let retryCount = 0;\n      let lastError = null;\n      \n      // Intentar con diferentes puertos si es necesario\n      const serverUrls = [\n        process.env.REACT_APP_API_URL, \n        'http://localhost:4001', // Nuevo puerto\n        'http://127.0.0.1:4001', // Nuevo puerto\n        'http://localhost:5000', // Puertos anteriores como fallback\n        'http://localhost:3333',\n        'http://127.0.0.1:5000',\n        'http://127.0.0.1:3333'\n      ].filter(Boolean); // Eliminar valores nulos o indefinidos\n      \n      console.log('Intentando conexión con las siguientes URLs:', serverUrls);\n      \n      // Intentar encontrar un servidor que responda\n      let foundServer = false;\n      \n      retry: while (retryCount < maxRetries && !foundServer) {\n        for (const serverUrl of serverUrls) {\n          try {\n            console.log(`Intento ${retryCount + 1}/${maxRetries} - Conectando a ${serverUrl}/api/auth/nonce`);\n            \n            const nonceResponse = await fetch(`${serverUrl}/api/auth/nonce`, {\n              headers: {\n                'Content-Type': 'application/json'\n              },\n              // Reducir el tiempo de espera para fallar más rápido si un servidor no responde\n              signal: AbortSignal.timeout(3000) \n            });\n            \n            const responseData = await nonceResponse.json();\n            console.log('Respuesta del servidor (nonce):', responseData);\n            \n            if (!responseData.success) {\n              console.error('Error al obtener nonce:', responseData);\n              lastError = responseData.message || 'Error al obtener nonce de autenticación';\n              continue; // Probar con la siguiente URL\n            }\n            \n            // Si llegamos aquí, hemos tenido éxito\n            console.log(`Conexión exitosa a ${serverUrl}`);\n            // Guardar la URL que funcionó para usarla en futuras solicitudes\n            localStorage.setItem('server_api_url', serverUrl);\n            nonceData = responseData;\n            foundServer = true;\n            break retry; // Salir de ambos bucles\n          } catch (error) {\n            console.error(`Error al conectar con ${serverUrl}:`, error);\n            lastError = error.message || 'Error de conexión al solicitar nonce';\n            // Continuamos con la siguiente URL\n          }\n        }\n        \n        retryCount++;\n        if (retryCount < maxRetries && !foundServer) {\n          console.log(`Reintentando en 1 segundo... (${retryCount}/${maxRetries})`);\n          await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar 1 segundo antes de reintentar\n        }\n      }\n      \n      // Si no se encontró ninguna conexión válida, devolver error\n      if (!foundServer || !nonceData) {\n        console.error('Todos los intentos de conexión fallaron');\n        return { success: false, error: `No se pudo conectar al servidor. ${lastError || 'Verifique que el servidor esté en ejecución.'}` };\n      }\n      \n      console.log('Nonce obtenido con éxito:', nonceData.message);\n      \n      // Firmar mensaje con nonce\n      console.log('Firmando mensaje con nonce:', nonceData.message);\n      let signature;\n      try {\n        signature = await signer.signMessage(nonceData.message);\n        console.log('Firma generada:', signature);\n        \n        if (!signature) {\n          console.error('No se generó firma');\n          return { success: false, error: 'Error al firmar el mensaje' };\n        }\n      } catch (signError) {\n        console.error('Error al firmar mensaje:', signError);\n        return { success: false, error: 'Error al firmar el mensaje: ' + signError.message };\n      }\n      \n      // Verificar firma en el servidor\n      console.log('Enviando datos para verificación:', {\n        address,\n        signature: signature ? 'presente' : 'ausente',\n        message: nonceData.message,\n        name: userName,\n        cedula: cedula\n      });\n      \n      let authData;\n      try {\n        // Usar la URL que funcionó para el nonce\n        const serverUrl = localStorage.getItem('server_api_url') || process.env.REACT_APP_API_URL || 'http://localhost:5000';\n        console.log(`Enviando verificación de firma a ${serverUrl}/api/auth/verify-signature`);\n        \n        const authResponse = await fetch(`${serverUrl}/api/auth/verify-signature`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            address,\n            signature,\n            message: nonceData.message,\n            name: userName || 'Usuario', // Asegurar que siempre haya un nombre\n            cedula: cedula\n          })\n        });\n        \n        authData = await authResponse.json();\n        console.log('Respuesta de verificación:', authData);\n        \n        if (!authData.success) {\n          console.error('Error en verificación:', authData);\n          return { success: false, error: authData.message || 'Error de autenticación' };\n        }\n      } catch (authError) {\n        console.error('Error al enviar verificación:', authError);\n        return { success: false, error: 'Error de conexión al verificar firma. Verifique que el servidor esté en ejecución.' };\n      }\n      \n      // Autenticaciu00f3n exitosa\n      return {\n        success: true,\n        address,\n        token: authData.token,\n        name: authData.name || 'Usuario'\n      };\n    } catch (error) {\n      console.error('Error en autenticaciu00f3n:', error);\n      return {\n        success: false,\n        error: error.message || 'Error desconocido durante la autenticaciu00f3n'\n      };\n    }\n  },\n  \n  /**\n   * Verifica si hay una sesiu00f3n activa guardada\n   * @returns {boolean}\n   */\n  hasActiveSession: () => {\n    const token = localStorage.getItem('auth_token');\n    const address = localStorage.getItem('user_address');\n    return !!(token && address);\n  },\n  \n  /**\n   * Obtiene el token de autenticaciu00f3n actual\n   * @returns {string|null}\n   */\n  getAuthToken: () => {\n    return localStorage.getItem('auth_token');\n  },\n  \n  /**\n   * Obtiene la direcciu00f3n de billetera guardada\n   * @returns {string|null}\n   */\n  getSavedAddress: () => {\n    return localStorage.getItem('user_address');\n  },\n  \n  /**\n   * Obtiene el nombre del usuario guardado\n   * @returns {string|null}\n   */\n  getSavedName: () => {\n    return localStorage.getItem('user_name');\n  },\n  \n  /**\n   * Guarda la informaciu00f3n de sesiu00f3n\n   * @param {string} address - Direcciu00f3n de la billetera\n   * @param {string} token - Token JWT\n   * @param {string} name - Nombre del usuario\n   */\n  saveSession: (address, token, name) => {\n    localStorage.setItem('auth_token', token);\n    localStorage.setItem('user_address', address);\n    localStorage.setItem('user_name', name);\n  },\n  \n  /**\n   * Cierra la sesiu00f3n\n   */\n  logout: () => {\n    localStorage.removeItem('auth_token');\n    localStorage.removeItem('user_address');\n    localStorage.removeItem('user_name');\n  },\n  \n  /**\n   * Verifica si la direcciu00f3n proporcionada es un administrador\n   * @param {string} address - Direcciu00f3n a verificar\n   * @returns {boolean}\n   */\n  isAdmin: (address) => {\n    const adminAddress = process.env.REACT_APP_ADMIN_ADDRESS;\n    if (!adminAddress || !address) return false;\n    return address.toLowerCase() === adminAddress.toLowerCase();\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}