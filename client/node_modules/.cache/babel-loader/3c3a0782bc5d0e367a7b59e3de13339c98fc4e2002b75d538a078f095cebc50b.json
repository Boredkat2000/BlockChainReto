{"ast":null,"code":"import { signMessage, setupWeb3Provider, getConnectedAddress } from '../utils/web3Utils';\n\n/**\n * Servicio de autenticaciu00f3n para manejar la conexiu00f3n con MetaMask y firma de mensajes\n */\nexport const authService = {\n  /**\n   * Conecta con MetaMask y autentica al usuario\n   * @param {string} userName - Nombre del usuario (opcional)\n   * @param {string} cedula - Cédula de identidad dominicana\n   * @returns {Promise<{success: boolean, address: string, token: string, name: string}|{success: boolean, error: string}>}\n   */\n  connectWallet: async (userName = '', cedula = '') => {\n    try {\n      console.log('Iniciando conectWallet con:', {\n        userName,\n        cedula\n      });\n\n      // Validación más estricta para la cédula\n      if (!cedula) {\n        console.error('Cédula completamente vacía');\n        return {\n          success: false,\n          error: 'Cédula no proporcionada'\n        };\n      }\n      if (typeof cedula !== 'string' && typeof cedula !== 'number') {\n        console.error('Tipo de cédula incorrecto:', typeof cedula);\n        return {\n          success: false,\n          error: `Cédula con formato incorrecto (${typeof cedula})`\n        };\n      }\n\n      // Limpiar y verificar la cédula - asegurarse de convertirla a string\n      const cedulaStr = String(cedula);\n      const cleanCedula = cedulaStr.replace(/[-\\s]/g, '');\n      console.log('Cédula original:', cedula);\n      console.log('Cédula como string:', cedulaStr);\n      console.log('Cédula limpia para validación:', cleanCedula, 'Longitud:', cleanCedula.length);\n\n      // Verificar que solo contiene números\n      if (!/^\\d+$/.test(cleanCedula)) {\n        console.error('La cédula contiene caracteres no numéricos:', cleanCedula);\n        return {\n          success: false,\n          error: 'La cédula solo debe contener números'\n        };\n      }\n\n      // Verificar formato de cédula dominicana\n      const cedulaRegex = /^(012|402)\\d{8}$/;\n      if (!cedulaRegex.test(cleanCedula)) {\n        console.error('Formato de cédula inválido:', cleanCedula);\n        return {\n          success: false,\n          error: 'Formato de cédula inválido. Debe comenzar con 012 o 402 y tener 11 dígitos.'\n        };\n      }\n\n      // Configurar proveedor Web3\n      const web3Setup = await setupWeb3Provider();\n      if (!web3Setup) {\n        console.error('No se pudo configurar Web3');\n        return {\n          success: false,\n          error: 'No se pudo conectar a MetaMask'\n        };\n      }\n      const {\n        provider,\n        signer\n      } = web3Setup;\n      const address = await signer.getAddress();\n      if (!address) {\n        console.error('No se pudo obtener dirección de billetera');\n        return {\n          success: false,\n          error: 'No se pudo obtener la dirección de la billetera'\n        };\n      }\n      console.log('Dirección obtenida:', address);\n\n      // Obtener nonce del servidor\n      console.log('Solicitando nonce al servidor...');\n      let nonceData;\n      try {\n        const nonceResponse = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:5000'}/api/auth/nonce`, {\n          headers: {\n            'Content-Type': 'application/json'\n          }\n        });\n        nonceData = await nonceResponse.json();\n        console.log('Respuesta del servidor (nonce):', nonceData);\n        if (!nonceData.success) {\n          console.error('Error al obtener nonce:', nonceData);\n          return {\n            success: false,\n            error: nonceData.message || 'Error al obtener nonce de autenticación'\n          };\n        }\n      } catch (nonceError) {\n        console.error('Error en solicitud de nonce:', nonceError);\n        return {\n          success: false,\n          error: 'Error de conexión al solicitar nonce'\n        };\n      }\n\n      // Firmar mensaje con nonce\n      console.log('Firmando mensaje con nonce:', nonceData.message);\n      let signature;\n      try {\n        signature = await signer.signMessage(nonceData.message);\n        console.log('Firma generada:', signature);\n        if (!signature) {\n          console.error('No se generó firma');\n          return {\n            success: false,\n            error: 'Error al firmar el mensaje'\n          };\n        }\n      } catch (signError) {\n        console.error('Error al firmar mensaje:', signError);\n        return {\n          success: false,\n          error: 'Error al firmar el mensaje: ' + signError.message\n        };\n      }\n\n      // Verificar firma en el servidor\n      console.log('Enviando datos para verificación:', {\n        address,\n        signature: signature ? 'presente' : 'ausente',\n        message: nonceData.message,\n        name: userName,\n        cedula: cedula\n      });\n      let authData;\n      try {\n        const authResponse = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:5000'}/api/auth/verify-signature`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            address,\n            signature,\n            message: nonceData.message,\n            name: userName || 'Usuario',\n            // Asegurar que siempre haya un nombre\n            cedula: cedula\n          })\n        });\n        authData = await authResponse.json();\n        console.log('Respuesta de verificación:', authData);\n        if (!authData.success) {\n          console.error('Error en verificación:', authData);\n          return {\n            success: false,\n            error: authData.message || 'Error de autenticación'\n          };\n        }\n      } catch (authError) {\n        console.error('Error al enviar verificación:', authError);\n        return {\n          success: false,\n          error: 'Error de conexión al verificar firma'\n        };\n      }\n\n      // Autenticaciu00f3n exitosa\n      return {\n        success: true,\n        address,\n        token: authData.token,\n        name: authData.name || 'Usuario'\n      };\n    } catch (error) {\n      console.error('Error en autenticaciu00f3n:', error);\n      return {\n        success: false,\n        error: error.message || 'Error desconocido durante la autenticaciu00f3n'\n      };\n    }\n  },\n  /**\n   * Verifica si hay una sesiu00f3n activa guardada\n   * @returns {boolean}\n   */\n  hasActiveSession: () => {\n    const token = localStorage.getItem('auth_token');\n    const address = localStorage.getItem('user_address');\n    return !!(token && address);\n  },\n  /**\n   * Obtiene el token de autenticaciu00f3n actual\n   * @returns {string|null}\n   */\n  getAuthToken: () => {\n    return localStorage.getItem('auth_token');\n  },\n  /**\n   * Obtiene la direcciu00f3n de billetera guardada\n   * @returns {string|null}\n   */\n  getSavedAddress: () => {\n    return localStorage.getItem('user_address');\n  },\n  /**\n   * Obtiene el nombre del usuario guardado\n   * @returns {string|null}\n   */\n  getSavedName: () => {\n    return localStorage.getItem('user_name');\n  },\n  /**\n   * Guarda la informaciu00f3n de sesiu00f3n\n   * @param {string} address - Direcciu00f3n de la billetera\n   * @param {string} token - Token JWT\n   * @param {string} name - Nombre del usuario\n   */\n  saveSession: (address, token, name) => {\n    localStorage.setItem('auth_token', token);\n    localStorage.setItem('user_address', address);\n    localStorage.setItem('user_name', name);\n  },\n  /**\n   * Cierra la sesiu00f3n\n   */\n  logout: () => {\n    localStorage.removeItem('auth_token');\n    localStorage.removeItem('user_address');\n    localStorage.removeItem('user_name');\n  },\n  /**\n   * Verifica si la direcciu00f3n proporcionada es un administrador\n   * @param {string} address - Direcciu00f3n a verificar\n   * @returns {boolean}\n   */\n  isAdmin: address => {\n    const adminAddress = process.env.REACT_APP_ADMIN_ADDRESS;\n    if (!adminAddress || !address) return false;\n    return address.toLowerCase() === adminAddress.toLowerCase();\n  }\n};","map":{"version":3,"names":["signMessage","setupWeb3Provider","getConnectedAddress","authService","connectWallet","userName","cedula","console","log","error","success","cedulaStr","String","cleanCedula","replace","length","test","cedulaRegex","web3Setup","provider","signer","address","getAddress","nonceData","nonceResponse","fetch","process","env","REACT_APP_API_URL","headers","json","message","nonceError","signature","signError","name","authData","authResponse","method","body","JSON","stringify","authError","token","hasActiveSession","localStorage","getItem","getAuthToken","getSavedAddress","getSavedName","saveSession","setItem","logout","removeItem","isAdmin","adminAddress","REACT_APP_ADMIN_ADDRESS","toLowerCase"],"sources":["C:/Users/katri/CascadeProjects/blockchain-voting-platform/client/src/services/authService.js"],"sourcesContent":["import { signMessage, setupWeb3Provider, getConnectedAddress } from '../utils/web3Utils';\n\n/**\n * Servicio de autenticaciu00f3n para manejar la conexiu00f3n con MetaMask y firma de mensajes\n */\nexport const authService = {\n  /**\n   * Conecta con MetaMask y autentica al usuario\n   * @param {string} userName - Nombre del usuario (opcional)\n   * @param {string} cedula - Cédula de identidad dominicana\n   * @returns {Promise<{success: boolean, address: string, token: string, name: string}|{success: boolean, error: string}>}\n   */\n  connectWallet: async (userName = '', cedula = '') => {\n    try {\n      console.log('Iniciando conectWallet con:', { userName, cedula });\n      \n      // Validación más estricta para la cédula\n      if (!cedula) {\n        console.error('Cédula completamente vacía');\n        return { success: false, error: 'Cédula no proporcionada' };\n      }\n      \n      if (typeof cedula !== 'string' && typeof cedula !== 'number') {\n        console.error('Tipo de cédula incorrecto:', typeof cedula);\n        return { success: false, error: `Cédula con formato incorrecto (${typeof cedula})` };\n      }\n      \n      // Limpiar y verificar la cédula - asegurarse de convertirla a string\n      const cedulaStr = String(cedula);\n      const cleanCedula = cedulaStr.replace(/[-\\s]/g, '');\n      console.log('Cédula original:', cedula);\n      console.log('Cédula como string:', cedulaStr);\n      console.log('Cédula limpia para validación:', cleanCedula, 'Longitud:', cleanCedula.length);\n      \n      // Verificar que solo contiene números\n      if (!/^\\d+$/.test(cleanCedula)) {\n        console.error('La cédula contiene caracteres no numéricos:', cleanCedula);\n        return { success: false, error: 'La cédula solo debe contener números' };\n      }\n      \n      // Verificar formato de cédula dominicana\n      const cedulaRegex = /^(012|402)\\d{8}$/;\n      if (!cedulaRegex.test(cleanCedula)) {\n        console.error('Formato de cédula inválido:', cleanCedula);\n        return { success: false, error: 'Formato de cédula inválido. Debe comenzar con 012 o 402 y tener 11 dígitos.' };\n      }\n      \n      // Configurar proveedor Web3\n      const web3Setup = await setupWeb3Provider();\n      if (!web3Setup) {\n        console.error('No se pudo configurar Web3');\n        return { success: false, error: 'No se pudo conectar a MetaMask' };\n      }\n      \n      const { provider, signer } = web3Setup;\n      const address = await signer.getAddress();\n      \n      if (!address) {\n        console.error('No se pudo obtener dirección de billetera');\n        return { success: false, error: 'No se pudo obtener la dirección de la billetera' };\n      }\n      \n      console.log('Dirección obtenida:', address);\n      \n      // Obtener nonce del servidor\n      console.log('Solicitando nonce al servidor...');\n      let nonceData;\n      try {\n        const nonceResponse = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:5000'}/api/auth/nonce`, {\n          headers: {\n            'Content-Type': 'application/json'\n          }\n        });\n        \n        nonceData = await nonceResponse.json();\n        console.log('Respuesta del servidor (nonce):', nonceData);\n        \n        if (!nonceData.success) {\n          console.error('Error al obtener nonce:', nonceData);\n          return { success: false, error: nonceData.message || 'Error al obtener nonce de autenticación' };\n        }\n      } catch (nonceError) {\n        console.error('Error en solicitud de nonce:', nonceError);\n        return { success: false, error: 'Error de conexión al solicitar nonce' };\n      }\n      \n      // Firmar mensaje con nonce\n      console.log('Firmando mensaje con nonce:', nonceData.message);\n      let signature;\n      try {\n        signature = await signer.signMessage(nonceData.message);\n        console.log('Firma generada:', signature);\n        \n        if (!signature) {\n          console.error('No se generó firma');\n          return { success: false, error: 'Error al firmar el mensaje' };\n        }\n      } catch (signError) {\n        console.error('Error al firmar mensaje:', signError);\n        return { success: false, error: 'Error al firmar el mensaje: ' + signError.message };\n      }\n      \n      // Verificar firma en el servidor\n      console.log('Enviando datos para verificación:', {\n        address,\n        signature: signature ? 'presente' : 'ausente',\n        message: nonceData.message,\n        name: userName,\n        cedula: cedula\n      });\n      \n      let authData;\n      try {\n        const authResponse = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:5000'}/api/auth/verify-signature`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            address,\n            signature,\n            message: nonceData.message,\n            name: userName || 'Usuario', // Asegurar que siempre haya un nombre\n            cedula: cedula\n          })\n        });\n        \n        authData = await authResponse.json();\n        console.log('Respuesta de verificación:', authData);\n        \n        if (!authData.success) {\n          console.error('Error en verificación:', authData);\n          return { success: false, error: authData.message || 'Error de autenticación' };\n        }\n      } catch (authError) {\n        console.error('Error al enviar verificación:', authError);\n        return { success: false, error: 'Error de conexión al verificar firma' };\n      }\n      \n      // Autenticaciu00f3n exitosa\n      return {\n        success: true,\n        address,\n        token: authData.token,\n        name: authData.name || 'Usuario'\n      };\n    } catch (error) {\n      console.error('Error en autenticaciu00f3n:', error);\n      return {\n        success: false,\n        error: error.message || 'Error desconocido durante la autenticaciu00f3n'\n      };\n    }\n  },\n  \n  /**\n   * Verifica si hay una sesiu00f3n activa guardada\n   * @returns {boolean}\n   */\n  hasActiveSession: () => {\n    const token = localStorage.getItem('auth_token');\n    const address = localStorage.getItem('user_address');\n    return !!(token && address);\n  },\n  \n  /**\n   * Obtiene el token de autenticaciu00f3n actual\n   * @returns {string|null}\n   */\n  getAuthToken: () => {\n    return localStorage.getItem('auth_token');\n  },\n  \n  /**\n   * Obtiene la direcciu00f3n de billetera guardada\n   * @returns {string|null}\n   */\n  getSavedAddress: () => {\n    return localStorage.getItem('user_address');\n  },\n  \n  /**\n   * Obtiene el nombre del usuario guardado\n   * @returns {string|null}\n   */\n  getSavedName: () => {\n    return localStorage.getItem('user_name');\n  },\n  \n  /**\n   * Guarda la informaciu00f3n de sesiu00f3n\n   * @param {string} address - Direcciu00f3n de la billetera\n   * @param {string} token - Token JWT\n   * @param {string} name - Nombre del usuario\n   */\n  saveSession: (address, token, name) => {\n    localStorage.setItem('auth_token', token);\n    localStorage.setItem('user_address', address);\n    localStorage.setItem('user_name', name);\n  },\n  \n  /**\n   * Cierra la sesiu00f3n\n   */\n  logout: () => {\n    localStorage.removeItem('auth_token');\n    localStorage.removeItem('user_address');\n    localStorage.removeItem('user_name');\n  },\n  \n  /**\n   * Verifica si la direcciu00f3n proporcionada es un administrador\n   * @param {string} address - Direcciu00f3n a verificar\n   * @returns {boolean}\n   */\n  isAdmin: (address) => {\n    const adminAddress = process.env.REACT_APP_ADMIN_ADDRESS;\n    if (!adminAddress || !address) return false;\n    return address.toLowerCase() === adminAddress.toLowerCase();\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}